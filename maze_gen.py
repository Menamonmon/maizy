from grid import *

class MazeGeneration:

	def __init__(self):
		pygame.init()
		self.DISPLAY = pygame.display.set_mode((600, 600))
		pygame.display.set_caption('Grid Test')

		# grid_size = int(input("What do you want the size of the grid to be???"))
		self.grid = Grid(self.DISPLAY, 20)

		self.checking = True
		self._start_cell = None
		self._end_cell = None
		self.choosing_start = False
		self.choosing_end = False
		self.algo_started = False
		self.start_cell = self.grid[0][0]
		self.end_cell = self.grid[-1][-1]
		self.clicking_thread = Thread(target=self.check_cells)
		self.clicking_thread.start()
		self.fps = 0
		self.ready = True
		self.solution_is_visible = False
		self.recursion_depth = 0

	@property
	def start_cell(self):
		return self._start_cell
		
	@start_cell.setter
	def start_cell(self, cell):
		if self._start_cell is not None:
			self.start_cell.is_start = False
		cell.is_start = True
		self._start_cell = cell
	
	@property
	def end_cell(self):
		return self._end_cell
		
	@end_cell.setter
	def end_cell(self, cell):
		if self._end_cell is not None:
			self.end_cell.is_end = False
		cell.is_end = True
		self._end_cell = cell

	def reset(self):
		self.grid.reset()
		self.start_cell = self.grid[0][0]
		self.end_cell = self.grid[-1][-1]
		self.clicking_thread = Thread(target=self.check_cells)
		self.clicking_thread.start()
		self.ready = True
		self.solution_is_visible = False
		print('Everything is reset.')

	def check_cells(self, cell_list=None):
		if cell_list is None:
			cell_list = self.grid.cell_list
		while self.checking and not self.algo_started:
			for row in cell_list:
				for cell in row:
					if cell.is_clicked():
						pass

	def update_display(self):
		# self.DISPLAY.fill((255, 255, 255))
		self.grid.draw()
		pygame.display.update()

	def dfs(self):
		self.algo_started = True
		self.ready = False
		self.path = []
		self.recursion_depth = 0
		self.search(self.start_cell)
		self.algo_started = False
	
	def search(self, current_cell):
		self.recursion_depth += 1
		if self.recursion_depth < 900:
			current_neighbors = current_cell.neighbors
			for n in current_neighbors:
				n.is_branch = True
			while len(current_cell.neighbors) > 0: # while the current cell has any unvisted neighbor cells
				random_neighbor = rd.choice(current_cell.neighbors)
				remove_wall_between(current_cell, random_neighbor)
				current_cell.is_current_cell = False
				current_cell = random_neighbor
				current_cell.choose()
				current_cell.is_current_cell = True
				self.path.append(current_cell.position)
				self.search(current_cell)
		else:
			self.reset()
			print("This maze is too big to be generated by DFS try any of the other algorithms.")	
			return	

	def recursive_backtracking(self):
		self.algo_started = True
		self.ready = False
		stack = []
		self.fps = 0
		current_cell = self.start_cell
		current_cell.choose()
		stack.append(current_cell)
		while True:
			
			current_neighbors = current_cell.neighbors
			if len(current_neighbors) > 0:
				random_neighbor = rd.choice(current_neighbors)
				remove_wall_between(current_cell, random_neighbor)
				current_cell = random_neighbor
				current_cell.choose()
				stack.append(current_cell)
			else:
				current_cell = stack.pop()
				current_cell.choose()

			if current_cell == self.start_cell:
				print('Maze is done')
				self.algo_started = False
				break

	def prim(self):
		self.algo_started = True
		self.ready = False
		maze_cells = []
		wall_list = []
		current_cell = self.start_cell
		maze_cells.append(current_cell)
		current_cell.choose()
		wall_list += self.grid.walls_for_cell(current_cell)
		while len(wall_list) > 0:
			random_wall = rd.choice(wall_list)
			associated_cells = [cell for cell in random_wall.cells if not cell.visited]
			if len(associated_cells) == 1:
				cells = random_wall.cells
				c1, c2 = cells[0], cells[1]
				remove_wall_between(c1, c2)
				current_cell = associated_cells[0]
				maze_cells.append(current_cell)
				current_cell.choose()
				# current_cell.update()
				wall_list += self.grid.walls_for_cell(current_cell)
			wall_list.remove(random_wall)

		print("Maze is done.")
		self.update_display()

	def backtracking_solution(self):
		solution = []
		current_cell = self.start_cell
		current_cell.used_in_path = True
		while current_cell != self.end_cell:
			open_neighbors = current_cell.open_sides
			if len(open_neighbors):
				if current_cell not in solution:
					solution.append(current_cell)
				current_cell = rd.choice(open_neighbors)
				current_cell.used_in_path = True
			else:
				current_cell = solution.pop()

		for cell in solution:
			cell.part_of_path = True
		solution_positions = [cell.position for cell in solution]
		self.solution_is_visible = True
		return tuple(solution_positions), len(solution_positions)
	
	def deadend_solution(self):
		dead_ends = []
		# making a list of dead ends
		for row in self.grid:
			for cell in row:
				if len(cell.open_sides) == 1:
					if (cell.position != self.start_cell.position and cell.position != self.end_cell.position):
						dead_ends.append(cell)
		
		# filling the dead ends
		for deadEnd in dead_ends:
			self.fill_dead_end(deadEnd)

		solution = []
		# marking all the cells other than that path of the dead ends as part of the solution
		for row in self.grid:
			for cell in row:
				if not cell.used_in_path:
					# cell.part_of_path = True
					solution.append(cell)

		# sorting the list of the solution based on the value of the position and marking them as part of the path and updating their color
		solution = sorted(solution, key=lambda x: sum(x.position))
		for cell in solution:
			cell.part_of_path = True
			cell.update()
		
		# converting the solution list from cells to their positions
		solution = [cell.position for cell in solution]
		self.solution_is_visible = True
		return solution, len(solution)

	def fill_dead_end(self, cell):
		current_cell = cell
		while len(current_cell.open_sides) == 1 and current_cell != self.end_cell:
			if current_cell != self.start_cell:	
				current_cell.used_in_path = True
				current_cell = current_cell.open_sides[0]
				current_cell.update()
			else:
				break

	def make_maze(self, algo_number):
		if self.ready:
			if algo_number == 0:
				self.recursive_backtracking()
			elif algo_number == 1:
				self.dfs()
			elif algo_number == 2:
				self.prim()
			else:
				print("Invlid algorithm id")
		else:
			print("You need to reset the grid first using the key 'r' before generating a new one")

	def solve_maze(self, sol_num):
		if not self.solution_is_visible:
			if sol_num == 0:
				self.backtracking_solution()
			elif sol_num == 1:
				self.deadend_solution()
			else:
				raise Exception('Invalid solution number')
			
		else:
			print('The solution is already visible')

	def mainloop(self):
		running = True
		while running:

			for event in pygame.event.get():
				if event.type == pygame.QUIT:
					self.checking = False
					running = False

				if event.type == pygame.KEYDOWN:
					if event.key == pygame.K_s:
						self.choosing_start = True
					elif event.key == pygame.K_e:
						self.choosing_end = True
					elif event.key == pygame.K_RETURN:
						# algo_num = int(input("Which algo do you want to use??\n"))
						self.make_maze(2)
					elif event.key == pygame.K_r:
						self.reset()
					elif event.key == pygame.K_SPACE:
						remove_wall_between(self.grid[0][0], self.grid[1][0])
					elif event.key == pygame.K_p:
						self.solve_maze(1)
			
				if event.type == pygame.KEYUP:
					if event.key == pygame.K_s:
						self.choosing_start = False
					elif event.key == pygame.K_e:
						self.choosing_end = False
				
			self.update_display()
		pygame.quit()


def main():
	app = MazeGeneration()
	app.mainloop()

if __name__ == "__main__":
	main()